<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hao&#39;s 博客</title>
  
  <subtitle>一点浩然气，千里快哉风</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-20T02:04:47.796Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web</title>
    <link href="http://yoursite.com/2020/05/15/web/"/>
    <id>http://yoursite.com/2020/05/15/web/</id>
    <published>2020-05-15T11:53:46.000Z</published>
    <updated>2020-05-20T02:04:47.796Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 什么是跨域</strong></p><p>由于同源策略的限制，浏览器不能执行其他网站的脚本</p><ul><li>同源策略（same-origin policy)</li></ul><p>1995年，同源策略由netscape公司引入，目前所有浏览器都实行了这个策略，它最初的含义是指：A网页的cookie，B网页不能打开，除非这两个网页同源，所谓的同源指下面三个相同</p><ol><li>协议相同</li><li>域名相同</li><li>端口相同</li></ol><ul><li>限制的行为</li></ul><ol><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM无法获得</li><li>ajax请求不能发送</li></ol><ul><li>跨域的判定</li></ul><ol><li>访问一个页面时，浏览器先根据同源策略对前端页面和后台交互地址做匹配，若同源，则直接发送数据请求；若不同源，则发送跨域请求。</li><li>服务器解析程序收到浏览器跨域请求后，根据自身配置返回对应文件头。若未配置过任何允许跨域，则文件头里不包含<code>Access-Control-Allow-origin</code>字段，若配置过域名，则返回<code>Access-Control-Allow-origin</code>+ <code>对应配置规则里的域名的方式</code>。</li><li>浏览器根据接受到的http文件头里的<code>Access-Control-Allow-origin</code>字段做匹配，若无该字段，说明不允许跨域；若有该字段，则对字段内容和当前域名做比对，如果同源，则说明可以跨域，浏览器发送该请求；若不同源，则说明该域名不可跨域，不发送请求</li></ol><p><strong>2. 你有解决过跨域的请求么</strong></p><p><strong>3. json和xml有什么区别</strong></p><p>1、JSON是JavaScript Object Notation；XML是可扩展标记语言。</p><p>2、JSON是基于JavaScript语言；XML源自SGML。</p><p>3、JSON是一种表示对象的方式；XML是一种标记语言，使用标记结构来表示数据项。</p><p>4、JSON不提供对命名空间的任何支持；XML支持名称空间。</p><p>5、JSON支持数组；XML不支持数组。</p><p>6、XML的文件相对难以阅读和解释；与XML相比，JSON的文件非常易于阅读。</p><p>7、JSON不使用结束标记；XML有开始和结束标签。</p><p>8、JSON的安全性较低；XML比JSON更安全。</p><p>9、JSON不支持注释；XML支持注释。</p><p>10、JSON仅支持UTF-8编码；XML支持各种编码。<br><strong>4. 如何理解js中的闭包</strong><br>js中变量的作用域可以分为全局变量和局部变量，闭包就是能够读取其他函数内部变量的函数，由于在Js语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p><p>用途：</p><ol><li>读取函数内部的变量</li><li>让这些变量的值始终保持在内存中</li></ol><p>使用闭包时要注意的点：</p><ol><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE浏览器中可能导致oom,其中的一个解决方法就是在退出函数之前，将不使用的局部变量全部删除</li><li>把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），不要随便改变父函数内部变量的值。</li></ol><p><strong>5. 清除浮动的几种方式</strong></p><ol><li><p>运用clear的方式在需要清浮动的元素下放一个div，并加上<code>clear:both</code> </p></li><li><p>方式是用伪元素<code>:before</code>或<code>:after</code> </p></li><li><p>父级标签overflow:hidden</p></li></ol><p>该方法利用了BFC的特性，当元素有以下特性时，触发BFC</p><ul><li><code>html</code>根元素</li><li><code>float</code>的值不为<code>none</code></li><li><code>overflow</code>的值为hidden、auto或scroll</li><li><code>position</code>的值不为<code>static</code>或<code>relative</code></li><li><code>display</code>的值为<code>table-cell</code>、<code>table-caption</code>、或<code>inline-block</code></li></ul><p><strong>6. 如何理解MVVM和MVC</strong><br>MVVM： 是Model-View-ViewModel的简写。即模型-视图-视图模型。【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。</p><p>MVC： 是Model-View- Controller的简写。即模型-视图-控制器。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下</p><p><strong>7. 谈一谈你对vue生命周期的理解</strong></p><p><strong>beforeCreate</strong>（创建前） 在数据观测和初始化事件还未开始<br><strong>created</strong>（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来<br>beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</p><p><strong>mounted</strong>（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</p><p><strong>beforeUpdate</strong>（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。<br><strong>updated</strong>（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。<br><strong>beforeDestroy</strong>（销毁前） 在实例销毁之前调用。实例仍然完全可用。<br><strong>destroyed</strong>（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p><p><strong>8. 如何理解css中的盒模型</strong></p><p>盒子模型有两种，分别是IE盒子模型和标准 w3c 盒子模型</p><p>标准盒子模型：</p><p>包括 margin、border、padding、content，并且 content 部分不包含其他部分</p><p>IE盒子模型：</p><p>包括 margin、border、padding、content，和标准盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading</p><p><strong>9. http中GET和POST的区别</strong></p><p>1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内</p><p>2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制</p><p>3.get后退不会有影响，post后退会重新进行提交</p><p>4.get请求可以被缓存，post不可以被缓存</p><p>5.get请求只URL编码，post支持多种编码方式</p><p>6.get请求的记录会留在历史记录中，post请求不会留在历史记录</p><p>7.get只支持ASCII字符，post没有字符类型限制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1. 什么是跨域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于同源策略的限制，浏览器不能执行其他网站的脚本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同源策略（same-origin policy)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1995年，同源策略由netscape公司引入，目前所
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
