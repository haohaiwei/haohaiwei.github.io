<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hao&#39;s 博客</title>
  
  <subtitle>一点浩然气，千里快哉风</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-27T11:06:37.836Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web</title>
    <link href="http://yoursite.com/2020/05/15/web/"/>
    <id>http://yoursite.com/2020/05/15/web/</id>
    <published>2020-05-15T11:53:46.000Z</published>
    <updated>2020-05-27T11:06:37.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><p><strong>1. 什么是跨域</strong></p><p>由于同源策略的限制，浏览器不能执行其他网站的脚本</p><ul><li>同源策略（same-origin policy)</li></ul><p>1995年，同源策略由netscape公司引入，目前所有浏览器都实行了这个策略，它最初的含义是指：A网页的cookie，B网页不能打开，除非这两个网页同源，所谓的同源指下面三个相同</p><ol><li>协议相同</li><li>域名相同</li><li>端口相同</li></ol><ul><li>限制的行为</li></ul><ol><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM无法获得</li><li>ajax请求不能发送</li></ol><ul><li>跨域的判定</li></ul><ol><li>访问一个页面时，浏览器先根据同源策略对前端页面和后台交互地址做匹配，若同源，则直接发送数据请求；若不同源，则发送跨域请求。</li><li>服务器解析程序收到浏览器跨域请求后，根据自身配置返回对应文件头。若未配置过任何允许跨域，则文件头里不包含<code>Access-Control-Allow-origin</code>字段，若配置过域名，则返回<code>Access-Control-Allow-origin</code>+ <code>对应配置规则里的域名的方式</code>。</li><li>浏览器根据接受到的http文件头里的<code>Access-Control-Allow-origin</code>字段做匹配，若无该字段，说明不允许跨域；若有该字段，则对字段内容和当前域名做比对，如果同源，则说明可以跨域，浏览器发送该请求；若不同源，则说明该域名不可跨域，不发送请求</li></ol><p><strong>2. json和xml有什么区别</strong></p><ol><li>JSON是JavaScript Object Notation；XML是可扩展标记语言。</li><li>JSON是基于JavaScript语言；XML源自SGML。</li><li>JSON是一种表示对象的方式；XML是一种标记语言，使用标记结构来表示数据项。</li><li>JSON不提供对命名空间的任何支持；XML支持名称空间。</li><li>JSON支持数组；XML不支持数组。</li><li>XML的文件相对难以阅读和解释；与XML相比，JSON的文件非常易于阅读。</li><li>JSON不使用结束标记；XML有开始和结束标签。</li><li>JSON的安全性较低；XML比JSON更安全。</li><li>JSON不支持注释；XML支持注释。</li><li>JSON仅支持UTF-8编码；XML支持各种编码。</li></ol><p><strong>3. vue的生命周期</strong></p><ol><li><p>beforeCreate（创建前） 在数据观测和初始化事件还未开始</p></li><li><p>created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有&gt;显示出来</p></li><li><p>beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完<br>成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到<br>页面上。</p></li><li><p>mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实&gt;例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</p></li><li><p>beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前<br>。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</p></li><li><p>updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用&gt;时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在<br>此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</p></li><li><p>beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。</p></li><li><p>destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p></li></ol><p><strong>4. 如何理解css中的盒模型</strong></p><p>盒子模型有两种，分别是IE盒子模型和标准 w3c 盒子模型</p><p>标准盒子模型：</p><p>包括 margin、border、padding、content，并且 content 部分不包含其他部分</p><p>IE盒子模型：</p><p>包括 margin、border、padding、content，和标准盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading</p><p><strong>5. js的数据类型</strong></p><ol><li>基本数据类型</li></ol><ul><li><code>number</code>类型</li><li><code>boolean</code>类型</li><li><code>string</code>类型</li><li><code>null</code>类型</li><li><code>undefined</code>类型</li></ul><ol start="2"><li>对象类型（即引用数据类型）</li></ol><ul><li><code>Object</code>类型,包括array、Object、function、data…等等</li></ul><p><strong>6. es6的特点</strong></p><ul><li>模块化</li><li>块级作用域</li><li>箭头函数</li></ul><p><strong>7. 渐进增强和优雅降级</strong></p><p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。<br>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容<br>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要</p><p><strong>8. http2多路复用</strong></p><p>多路复用：在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能<br>和http1的区别：HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效，http2是完全多路复用的，使用报头压缩</p><h1 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h1><p><strong>1. 如何理解js中的闭包</strong></p><p>js中变量的作用域可以分为全局变量和局部变量，闭包就是能够读取其他函数内部变量的函<br>数，由于在Js语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解<br>成”定义在一个函数内部的函数”。</p><p>用途：</p><ol><li>读取函数内部的变量</li><li>让这些变量的值始终保持在内存中</li></ol><p>使用闭包时要注意的点：</p><ol><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，&gt;否则会造成网页的性能问题，在IE浏览器中可能导致oom,其中的一个解决方法就是在退出函<br>数之前，将不使用的局部变量全部删除</li><li>把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），不要随便改变父函数内部变量的值。</li></ol><p><strong>2. 如何理解MVVM和MVC</strong></p><p>MVVM： 是Model-View-ViewModel的简写。即模型-视图-视图模型。【模型】指的是后端传&gt;递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和<br>model的桥梁。它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化&gt;成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到<br>的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之<br>为数据的双向绑定。</p><p>MVC： 是Model-View- Controller的简写。即模型-视图-控制器。M和V指的意思和MVVM中的<br>M和V意思一样。C即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离<br>。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下</p><p><strong>3. http中GET和POST的区别</strong></p><ol><li>get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内</li><li>get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制</li><li>get后退不会有影响，post后退会重新进行提交</li><li>get请求可以被缓存，post不可以被缓存</li><li>get请求只URL编码，post支持多种编码方式</li><li>get请求的记录会留在历史记录中，post请求不会留在历史记录</li><li>get只支持ASCII字符，post没有字符类型限制</li></ol><p><strong>4. HTTPS和HTTP的区别</strong></p><ul><li>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少</li><li>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL</li><li>区别：</li></ul><ol><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议</li><li>端口不同</li><li>http的连接很简单，是无状态的 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全</li><li>https需要申请CA证书</li></ol><p><strong>5. js的浅拷贝和深拷贝</strong></p><ul><li>浅拷贝：假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝</li><li>深拷贝：如果B没变，那就是深拷贝</li><li>区别：浅拷贝只复制一层对象的属性，深copy递归复制了所有层级，对于数据类型来说，key一般在栈内存里面，value在堆内存里面，浅copy只复制栈内存里面的，深copy则递归复制了所有层级</li></ul><p><strong>6. 栈和队列的区别</strong></p><ul><li>栈： 一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表</li><li>队列：队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</li><li>区别：栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。<br>栈是先进后出，队列是先进先出。栈只允许在表尾一端进行插入和删除，队列只允许在表尾一端进行插入，在表头一端进行删除</li></ul><p><strong>7. document.write和innerHTML的区别</strong></p><ul><li>document.write：直接将内容写入页面的内容流</li><li>innerHTML：将内容写入某个DOM节点</li><li>区别：document.write会导致页面全部重绘，innerHTML不会导致页面全部重绘</li></ul><p><strong>8. 如何理解长连接和短连接</strong></p><ul><li>长连接：连接–&gt; 数据传输–&gt; 保持连接–&gt; 数据传输–&gt; 保持连接–&gt; …………–&gt; 关闭连接</li><li>短链接：连接 –&gt; 数据传输–&gt; 关闭连接</li></ul><p><strong>9. sessionStorage、localStorage、cookie的区别</strong></p><ul><li>数据大小： cookie一般在4K，localStorage和sessionStorage则是5M或者更大</li><li>传递方式：cookie是在浏览器和服务器间来回传递，localStorage和sessionStorage不会自动把数据发给服务器，<br>仅在本地保存</li><li>有效期：cookie在过期时间到来之前始终有效，localStorage是始终有效，sessionStorage仅在当前浏览器窗口关闭前有效</li><li>作用域： cookie和localStorage一样，所有同源窗口共享，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面</li></ul><p><strong>10. js中undefined和null的区别</strong></p><ul><li>undefined：表示”缺少值”，就是此处应该有一个值，但是还没有定义</li><li>null：表示”没有对象”，即该处不应该有值</li></ul><p><strong>11. tcp的三次握手和四次挥手</strong></p><ul><li>三次握手（建立连接）：</li></ul><ol><li>发送端首先发送一个带有SYN（synchronize）标志地数据包给接收方。</li><li>接收方接收后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了。</li><li>最后，发送方再回传一个带有ACK标志的数据包，代表我知道了，表示’握手‘结束</li></ol><ul><li>四次挥手（断开连接）： </li></ul><ol><li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li><li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</li><li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li><li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手</li></ol><h1 id="实践篇"><a href="#实践篇" class="headerlink" title="实践篇"></a>实践篇</h1><p><strong>1. 清除浮动的几种方式</strong></p><ol><li>运用clear的方式在需要清浮动的元素下放一个div，并加上<code>clear:both</code></li><li>方式是用伪元素<code>:before</code>或<code>:after</code></li><li>父级标签overflow:hidden<br>该方法利用了BFC的特性，当元素有以下特性时，触发BFC</li></ol><ul><li><code>html</code>根元素</li><li><code>float</code>的值不为<code>none</code></li><li><code>overflow</code>的值为hidden、auto或scroll</li><li><code>position</code>的值不为<code>static</code>或<code>relative</code></li><li><code>display</code>的值为<code>table-cell</code>、<code>table-caption</code>、或<code>inline-block</code></li></ul><p><strong>2. 拖拽会用到哪些事件</strong></p><ul><li>dragstart 事件<br>当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上</li><li>dragenter 事件<br>当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上</li><li>dragover 事件<br>拖拽元素在目标元素上移动的时候触发的事件，此事件作用在目标元素上</li><li>dragleave 事件<br>拖拽元素在目标元素上移动的时候触发的事件，此事件作用在目标元素上</li><li>drop 事件<br>被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上</li><li>dragend 事件<br>当拖拽完成后触发的事件，此事件作用在被拖曳元素上</li></ul><p><strong>3. ajax的使用步骤</strong></p><ul><li>第一步，创建XMLHttpRequest对象,也就是创建一个异步调用对象</li><li>第二步，创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li><li>第三步，配置请求信息</li><li>第四步，发送HTTP请求</li><li>第五步，获取异步调用返回的数据.</li><li>第六步，)使用JavaScript和DOM实现局部刷新</li></ul><p><strong>4. ajax和jsonp的区别</strong></p><ul><li>ajax是通过创建XMLHttpRequest来获取同源的数据。而jsonp是通过<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本  </li></ul><h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><p><strong>1. 冒泡排序的过程</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数</li><li>针对所有的元素重复以上的步骤，除了最后一个</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li></ul><h1 id="开放性问答篇"><a href="#开放性问答篇" class="headerlink" title="开放性问答篇"></a>开放性问答篇</h1><p><strong>1. 如何理解前端工程师这个岗位</strong></p><p><strong>2. 你碰到最难的问题是什么，如何解决的</strong></p><p><strong>3. 你是如何解决跨域问题的</strong></p><h1 id="vue专题"><a href="#vue专题" class="headerlink" title="vue专题"></a>vue专题</h1><p><strong>1. 父组件向子组件传值的方法</strong></p><ul><li>props传值，这里注意一个问题，传过来的值需要用watch监听并赋值，否则这里获取到的是空数组</li><li>通过ref属性，父组件调用子组件的方法，把要传的数组作为参数传给子组件，子组件获取该参数，并使用</li></ul><p><strong>2. Vuex有哪几种属性</strong></p><p>有五种,分别是State , Getter , Mutation , Action , Module (就是mapAction)</p><p><strong>3. v-if 和 v-show有什么区别</strong></p><ul><li>实现方式</li></ul><ul><li>vue-show本质就是标签display设置为none，控制隐藏</li><li>vue-if是动态的向DOM树内添加或者删除DOM元素</li></ul><ul><li>编译的区别</li></ul><ul><li>v-show其实就是在控制css</li><li>v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件</li></ul><ul><li>编译的条件</li></ul><ul><li>v-show都会编译，初始值为false，只是将display设为none，但它也编译了</li><li>v-if初始值为false，就不会编译了</li></ul><ul><li>性能</li></ul><ul><li>v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点</li></ul><p><strong>4. vue常用的修饰符有哪些</strong></p><p><strong>5. 谈一谈你对vue的理解，有什么特点，为什么不能兼容IE8以下的浏览器</strong></p><h1 id="react专题"><a href="#react专题" class="headerlink" title="react专题"></a>react专题</h1><p><strong>1. react中key的作用</strong></p><p>key是React中用于追踪哪些列表中元素被修改、删除或者被添加的辅助标识。在diff算法中，key用来判断该元素节点是被移动过来的还是新创建的元素，减少不必要的元素重复渲染。<br><strong>2. sass和less的区别</strong></p><ul><li>符号不同</li></ul><ul><li>less是用@，sass使用$</li></ul><ul><li>作用域不同</li></ul><ul><li>less在全局定义，就作用在全局，在代码块中定义，就作用于整哥代码块。而sass只作用域全局。</li></ul><ul><li>编译环境不同<br>less在开发者环境编译，sass在服务器环境下编译。</li></ul><p><strong>3. react生命周期及相关用法</strong></p><ul><li><p>react生命周期分为初始化阶段、运行阶段、销毁阶段。</p></li><li><p>初始化阶段：</p></li></ul><ul><li>componentWillMount：实例挂载之前</li><li>Render：渲染组件</li><li>componentDidMount：实例挂载完成。一般在这个函数中与后台进行初始化数据交互。</li></ul><ul><li>运行阶段：</li></ul><ul><li>componentWillReceiveProps：父组件改变时调用。</li><li>sholudComponentUpdate：主要是用来手动阻止组件渲染，一般在这个函数中做组件的性能优化。</li><li>componentWillUpdate：组件数据更新前调用</li><li>componentDidUpdate：组件数据更新完成时调用</li></ul><ul><li>销毁阶段：</li></ul><ul><li>componentUnmount：销毁阶段。一般用来销毁不用的变量或者是解除无用定时器以及解绑无用事件。防止内存泄漏问题。</li></ul><p><strong>4. 真实DOM和虚拟DOM的区别</strong></p><table><thead><tr><th>真实DOM</th><th>虚拟DOM</th></tr></thead><tbody><tr><td>更新较慢</td><td>更新较快</td></tr><tr><td>可以直接更新HTML</td><td>不能直接更新HTML</td></tr><tr><td>元数更新时创建一个新的DOM</td><td>元素更新时更新JSX</td></tr><tr><td>DOM操作开销过大</td><td>DOM操作非常容易</td></tr><tr><td>内存浪费严重</td><td>没有内存浪费</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇&quot;&gt;&lt;/a&gt;基础篇&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1. 什么是跨域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于同源策略的限制，浏览器不能执行其他网站的脚本&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
